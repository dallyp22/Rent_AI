17 properties (buildings)
3,000 units total
353 unique TAGs that identify specific unit configurations
A clear hierarchy: Property → Bedroom Count → TAG

Proposed Database Enhancement Strategy
After reviewing your portfolio data, I strongly agree with your approach to create a deeper unit-level data layer. Here's my comprehensive plan:
1. Enhanced Database Schema
sql-- Enhanced property_profiles table (existing)
CREATE TABLE property_profiles (
  -- existing fields...
  
  -- Add new field for unit-level detail flag
  has_unit_details BOOLEAN DEFAULT FALSE,
  unit_detail_source TEXT, -- 'manual', 'import', 'scraping'
  
  -- existing fields...
);

-- NEW: Detailed unit inventory table
CREATE TABLE property_units_inventory (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  property_profile_id UUID REFERENCES property_profiles(id) ON DELETE CASCADE,
  
  -- Unit identification
  unit_number TEXT NOT NULL,
  tag TEXT NOT NULL, -- The TAG from your Excel (Moscow, 1/1 FRANC, etc.)
  
  -- Unit characteristics
  bedrooms INTEGER NOT NULL,
  bathrooms DECIMAL(3,1) NOT NULL,
  square_feet INTEGER,
  unit_type TEXT, -- From your "Unit Type" field
  
  -- Pricing data
  current_rent DECIMAL(10,2),
  optimal_rent DECIMAL(10,2), -- From AI optimization
  market_rent DECIMAL(10,2),  -- From competitive analysis
  
  -- Status and availability
  status TEXT DEFAULT 'occupied', -- occupied, vacant, maintenance
  lease_end_date DATE,
  days_on_market INTEGER,
  
  -- Competitive positioning
  rent_percentile DECIMAL(5,2), -- Where this unit ranks in market
  optimization_priority INTEGER, -- 1-5, for sorting recommendations
  
  -- Metadata
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  -- Unique constraint on property + unit number
  UNIQUE(property_profile_id, unit_number)
);

-- Index for fast sorting and filtering
CREATE INDEX idx_units_property_tag ON property_units_inventory(property_profile_id, tag);
CREATE INDEX idx_units_sorting ON property_units_inventory(property_profile_id, bedrooms, tag);
CREATE INDEX idx_units_optimization ON property_units_inventory(optimization_priority, tag);

-- NEW: TAG metadata table (for standardization)
CREATE TABLE tag_definitions (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  tag TEXT UNIQUE NOT NULL,
  category TEXT, -- 'city', 'unit_type', 'custom'
  display_order INTEGER, -- For consistent sorting
  description TEXT,
  
  -- Grouping for similar tags
  tag_group TEXT, -- e.g., 'Portland' for Portland.1, Portland.2, Portland.3
  
  created_at TIMESTAMP DEFAULT NOW()
);
2. Import Workflow from Excel
typescript// New API endpoint for bulk unit import
POST /api/property-profiles/:id/import-units

// TypeScript interface
interface UnitImportRow {
  unit: string;
  tag: string;
  beds: number;
  baths: number;
  sqft: number;
  unitType?: string;
}

// Import handler
async function importPropertyUnits(
  propertyProfileId: string, 
  excelFile: File
) {
  // Parse Excel
  const units = await parseExcel(excelFile);
  
  // Validate and standardize TAGs
  const tagDefinitions = await standardizeTags(units);
  
  // Bulk insert with conflict resolution
  await storage.bulkCreateUnits(propertyProfileId, units);
  
  // Mark property as having unit details
  await storage.updatePropertyProfile(propertyProfileId, {
    has_unit_details: true,
    unit_detail_source: 'import'
  });
}
3. Enhanced Optimization Sorting
The key insight from your Excel is the need for multi-level hierarchical sorting in the optimization recommendations:
typescriptinterface OptimizationSortStrategy {
  // Primary sort: Building/Property
  sortByProperty: (units: UnitOptimization[]) => Map<string, UnitOptimization[]>;
  
  // Secondary sort: Bedroom count within each property
  sortByBedroom: (units: UnitOptimization[]) => Map<number, UnitOptimization[]>;
  
  // Tertiary sort: TAG (with custom ordering)
  sortByTag: (units: UnitOptimization[]) => UnitOptimization[];
}

// Implementation for optimization report
function generateOptimizedReport(analysisSessionId: string) {
  const optimizations = await getOptimizations(analysisSessionId);
  
  // Group by Property → Bedroom → TAG
  const grouped = optimizations.reduce((acc, unit) => {
    const property = unit.propertyName;
    const bedroom = unit.bedrooms;
    const tag = unit.tag;
    
    if (!acc[property]) acc[property] = {};
    if (!acc[property][bedroom]) acc[property][bedroom] = [];
    
    acc[property][bedroom].push(unit);
    return acc;
  }, {});
  
  // Sort each level
  Object.keys(grouped).forEach(property => {
    Object.keys(grouped[property]).forEach(bedroom => {
      // Sort by TAG (using display_order from tag_definitions)
      grouped[property][bedroom].sort((a, b) => {
        return compareTagOrder(a.tag, b.tag);
      });
    });
  });
  
  return grouped;
}
4. Excel Export with TAG Sorting
typescript// Enhanced Excel export preserving TAG hierarchy
async function exportOptimizationReport(sessionId: string) {
  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet('Optimization Report');
  
  // Headers
  ws.addRow([
    'Property', 'Unit', 'TAG', 'Bedrooms', 'Bathrooms', 
    'Sq Ft', 'Current Rent', 'Optimal Rent', 'Increase', 
    'Annual Impact', 'Priority'
  ]);
  
  // Get sorted data
  const sortedData = await generateOptimizedReport(sessionId);
  
  // Write data maintaining hierarchy
  Object.keys(sortedData).sort().forEach(property => {
    // Add property section
    ws.addRow([property]).font = { bold: true };
    
    Object.keys(sortedData[property])
      .sort((a, b) => Number(a) - Number(b))
      .forEach(bedroom => {
        // Add bedroom subsection
        ws.addRow([`  ${bedroom} Bedroom Units`]).font = { italic: true };
        
        // Add units sorted by TAG
        sortedData[property][bedroom].forEach(unit => {
          ws.addRow([
            '    ', // Indent for hierarchy
            unit.unitNumber,
            unit.tag,
            unit.bedrooms,
            unit.bathrooms,
            unit.sqft,
            unit.currentRent,
            unit.optimalRent,
            unit.rentIncrease,
            unit.annualImpact,
            unit.priority
          ]);
        });
      });
    
    // Add subtotal row for property
    ws.addRow([`${property} Total`, '', '', '', '', '', 
               sumCurrentRent, sumOptimalRent, sumIncrease, sumAnnualImpact]);
  });
  
  return wb;
}
5. UI Enhancements for TAG-based Sorting
tsx// New component for optimization view with TAG filtering
function OptimizationDashboard({ sessionId }: Props) {
  const [sortBy, setSortBy] = useState<'property' | 'priority' | 'impact'>('property');
  const [filterTags, setFilterTags] = useState<string[]>([]);
  
  return (
    <div>
      {/* Hierarchical view */}
      <TreeView defaultExpanded={['all-properties']}>
        {properties.map(property => (
          <TreeItem key={property.id} nodeId={property.id} label={
            <PropertySummary property={property} />
          }>
            {bedrooms.map(bedroom => (
              <TreeItem key={bedroom} nodeId={`${property.id}-${bedroom}`} label={
                <BedroomSummary bedroom={bedroom} count={units.length} />
              }>
                {units.map(unit => (
                  <TreeItem key={unit.id} nodeId={unit.id} label={
                    <UnitOptimization unit={unit} tag={unit.tag} />
                  } />
                ))}
              </TreeItem>
            ))}
          </TreeItem>
        ))}
      </TreeView>
      
      {/* TAG cloud for filtering */}
      <TagCloud 
        tags={uniqueTags}
        selected={filterTags}
        onToggle={handleTagFilter}
      />
    </div>
  );
}
