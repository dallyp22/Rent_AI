import ExcelJS from 'exceljs';

export interface PortfolioExportData {
  portfolioSummary: {
    totalProperties: number;
    totalUnits: number;
    totalCurrentRevenue: number;
    totalOptimizedRevenue: number;
    totalOptimizationPotential: number;
    annualOptimizationPotential: number;
    avgPerformanceScore: number;
    portfolioROI: number;
    avgOccupancyRate: number;
    generatedAt: string;
    // New vacancy metrics
    avgPortfolioVacancy?: number;
    totalVacantUnits?: number;
  };
  propertyPerformance: Array<{
    propertyId: string;
    propertyName: string;
    address: string;
    totalUnits: number;
    currentMonthlyRevenue: number;
    optimizedMonthlyRevenue: number;
    optimizationPotential: number;
    annualOptimizationPotential: number;
    occupancyRate: number;
    performanceScore: number;
    lastAnalyzed: Date | string;
    // New vacancy metrics per property
    overallVacancy?: number;
    vacantUnits?: number;
    vacancyByBedroom?: {
      studio: number | null;
      oneBedroom: number | null;
      twoBedroom: number | null;
      threeBedroom: number | null;
      fourPlusBedroom: number | null;
    };
  }>;
  // New vacancy data section
  vacancyMetrics?: {
    portfolioVacancy: {
      overallVacancy: number;
      totalUnits: number;
      vacantUnits: number;
      vacancyByBedroom: {
        studio: number | null;
        oneBedroom: number | null;
        twoBedroom: number | null;
        threeBedroom: number | null;
        fourPlusBedroom: number | null;
      };
    };
    propertyVacancies: Array<{
      propertyId: string;
      propertyName: string;
      totalUnits: number;
      vacantUnits: number;
      overallVacancy: number;
      vacancyByBedroom: {
        studio: number | null;
        oneBedroom: number | null;
        twoBedroom: number | null;
        threeBedroom: number | null;
        fourPlusBedroom: number | null;
      };
    }>;
    marketPosition?: string;
    competitorAvgVacancy?: number;
  };
  trends?: {
    revenueGrowth: number;
    occupancyTrend: number;
    rentGrowth: number;
    optimizationSuccessRate: number;
  };
  insights?: {
    strategicRecommendations: Array<{
      category: string;
      priority: string;
      insight: string;
      actionItems: string[];
    }>;
    riskAssessment: {
      overallRiskLevel: string;
      recommendations: string[];
    };
  };
}

export async function exportPortfolioToExcel(
  data: PortfolioExportData, 
  reportType: 'summary' | 'financial' | 'performance' | 'executive'
): Promise<void> {
  // Validate required data
  if (!data.portfolioSummary) {
    throw new Error('Portfolio summary data is required for export');
  }
  
  if (!data.propertyPerformance || data.propertyPerformance.length === 0) {
    throw new Error('Property performance data is required for export');
  }
  const workbook = new ExcelJS.Workbook();
  workbook.creator = 'PropertyAnalytics Pro';
  workbook.lastModifiedBy = 'PropertyAnalytics Pro';
  workbook.created = new Date();
  workbook.modified = new Date();
  
  // Define common colors for branding
  const colors = {
    primaryBlue: 'FF2563EB',
    primaryGreen: 'FF059669',
    lightBlue: 'FFE0F2FE',
    lightGreen: 'FFDCFCE7',
    lightRed: 'FFFEF2F2',
    darkGray: 'FF374151',
    lightGray: 'FF9CA3AF'
  };

  if (reportType === 'summary' || reportType === 'executive') {
    await createSummarySheet(workbook, data, colors);
  }
  
  if (reportType === 'financial' || reportType === 'executive') {
    await createFinancialSheet(workbook, data, colors);
  }
  
  if (reportType === 'performance' || reportType === 'executive') {
    await createPerformanceSheet(workbook, data, colors);
  }
  
  // Add Vacancy Metrics sheet for all report types except basic summary
  if ((reportType === 'performance' || reportType === 'executive' || reportType === 'financial') && data.vacancyMetrics) {
    await createVacancySheet(workbook, data, colors);
  }
  
  if (reportType === 'executive' && data.insights) {
    await createInsightsSheet(workbook, data, colors);
  }

  // Generate and download the file
  const buffer = await workbook.xlsx.writeBuffer();
  const blob = new Blob([buffer], { 
    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
  });
  
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.href = url;
  
  const timestamp = new Date().toISOString().split('T')[0];
  const filename = `portfolio-${reportType}-report-${timestamp}.xlsx`;
  link.download = filename;
  
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

async function createSummarySheet(workbook: ExcelJS.Workbook, data: PortfolioExportData, colors: any) {
  const worksheet = workbook.addWorksheet('Portfolio Summary', {
    headerFooter: {
      firstHeader: 'Portfolio Summary Report',
      firstFooter: '&CGenerated by PropertyAnalytics Pro'
    }
  });

  // Title Section
  const titleRow = worksheet.addRow(['Portfolio Summary Report']);
  titleRow.getCell(1).font = { size: 20, bold: true, color: { argb: colors.primaryBlue } };
  titleRow.height = 35;
  
  worksheet.addRow(['Generated on:', new Date().toLocaleDateString()]);
  worksheet.addRow(['Report Period:', 'Current Portfolio Status']);
  worksheet.addRow([]);

  // Portfolio Overview Section
  const overviewHeader = worksheet.addRow(['Portfolio Overview']);
  overviewHeader.getCell(1).font = { size: 16, bold: true, color: { argb: colors.primaryGreen } };
  worksheet.addRow([]);

  const overviewData = [
    ['Metric', 'Value', 'Performance'],
    ['Total Properties', data.portfolioSummary.totalProperties, ''],
    ['Total Units', data.portfolioSummary.totalUnits, ''],
    ['Current Monthly Revenue', `$${data.portfolioSummary.totalCurrentRevenue.toLocaleString()}`, ''],
    ['Optimized Monthly Revenue', `$${data.portfolioSummary.totalOptimizedRevenue.toLocaleString()}`, ''],
    ['Monthly Optimization Potential', `$${data.portfolioSummary.totalOptimizationPotential.toLocaleString()}`, ''],
    ['Annual Optimization Potential', `$${data.portfolioSummary.annualOptimizationPotential.toLocaleString()}`, ''],
    ['Average Occupancy Rate', `${data.portfolioSummary.avgOccupancyRate.toFixed(1)}%`, data.portfolioSummary.avgOccupancyRate > 85 ? 'Excellent' : data.portfolioSummary.avgOccupancyRate > 75 ? 'Good' : 'Needs Attention'],
    ['Average Vacancy Rate', 
      data.portfolioSummary.avgPortfolioVacancy !== undefined ? 
        `${data.portfolioSummary.avgPortfolioVacancy.toFixed(1)}%` : 'N/A',
      data.portfolioSummary.avgPortfolioVacancy !== undefined ? 
        (data.portfolioSummary.avgPortfolioVacancy < 5 ? 'Excellent' :
         data.portfolioSummary.avgPortfolioVacancy < 15 ? 'Good' : 'Needs Attention') : ''
    ],
    ['Total Vacant Units',
      data.portfolioSummary.totalVacantUnits !== undefined ?
        `${data.portfolioSummary.totalVacantUnits} / ${data.portfolioSummary.totalUnits}` : 'N/A',
      ''
    ],
    ['Portfolio ROI', `${data.portfolioSummary.portfolioROI.toFixed(1)}%`, data.portfolioSummary.portfolioROI > 12 ? 'Above Average' : 'Market Rate'],
    ['Average Performance Score', `${data.portfolioSummary.avgPerformanceScore.toFixed(0)}/100`, data.portfolioSummary.avgPerformanceScore > 80 ? 'Excellent' : data.portfolioSummary.avgPerformanceScore > 70 ? 'Good' : 'Needs Improvement']
  ];

  let startRow = worksheet.rowCount + 1;
  overviewData.forEach((row, index) => {
    const excelRow = worksheet.addRow(row);
    if (index === 0) {
      // Header row
      excelRow.eachCell((cell) => {
        cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.primaryBlue } };
        cell.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
      });
    } else {
      // Data rows
      excelRow.eachCell((cell, colNumber) => {
        if (colNumber === 1) {
          cell.font = { bold: true };
        }
        if (colNumber === 2 && typeof row[1] === 'string' && row[1].startsWith('$')) {
          cell.font = { color: { argb: colors.primaryGreen }, bold: true };
        }
        cell.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
      });
    }
  });

  // Set column widths
  worksheet.columns = [
    { width: 30 }, // Metric
    { width: 25 }, // Value
    { width: 20 }  // Performance
  ];

  worksheet.addRow([]);
}

async function createFinancialSheet(workbook: ExcelJS.Workbook, data: PortfolioExportData, colors: any) {
  const worksheet = workbook.addWorksheet('Financial Analysis');

  // Title
  const titleRow = worksheet.addRow(['Portfolio Financial Analysis']);
  titleRow.getCell(1).font = { size: 18, bold: true, color: { argb: colors.primaryBlue } };
  titleRow.height = 30;
  
  worksheet.addRow(['As of:', new Date().toLocaleDateString()]);
  worksheet.addRow([]);

  // Property-by-Property Financial Performance
  const headerRow = worksheet.addRow([
    'Property Name',
    'Address',
    'Units',
    'Current Revenue',
    'Optimized Revenue',
    'Monthly Potential',
    'Annual Potential',
    'Occupancy %',
    'Vacancy %',
    'Vacant Units',
    'Avg Rent/Unit',
    'Performance Score'
  ]);

  // Style header row
  headerRow.eachCell((cell) => {
    cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.primaryBlue } };
    cell.border = {
      top: { style: 'thin' }, left: { style: 'thin' },
      bottom: { style: 'thin' }, right: { style: 'thin' }
    };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
  });

  // Add property data with safe property access and calculated avgRentPerUnit
  data.propertyPerformance.forEach((property) => {
    // Calculate avgRentPerUnit from currentMonthlyRevenue and occupied units estimate
    const avgRentPerUnit = property.totalUnits > 0 ? 
      property.currentMonthlyRevenue / (property.totalUnits * (property.occupancyRate / 100)) : 0;
    
    const row = worksheet.addRow([
      property.propertyName || 'Unknown',
      property.address || 'N/A',
      property.totalUnits || 0,
      property.currentMonthlyRevenue || 0,
      property.optimizedMonthlyRevenue || 0,
      property.optimizationPotential || 0,
      property.annualOptimizationPotential || 0,
      property.occupancyRate || 0,
      property.overallVacancy !== undefined ? property.overallVacancy : 'N/A',
      property.vacantUnits !== undefined ? property.vacantUnits : 'N/A',
      avgRentPerUnit,
      property.performanceScore || 0
    ]);

    // Apply conditional formatting
    row.eachCell((cell, colNumber) => {
      cell.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };

      // Format currency columns
      if ([4, 5, 6, 7, 11].includes(colNumber)) {
        cell.numFmt = '"$"#,##0.00';
      }
      
      // Format percentage columns
      if (colNumber === 8) {
        cell.numFmt = '0.0"%"';
      }
      
      // Format vacancy percentage
      if (colNumber === 9 && typeof cell.value === 'number') {
        cell.numFmt = '0.0"%"';
        // Color code vacancy rate
        if (property.overallVacancy !== undefined) {
          if (property.overallVacancy <= 5) {
            cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.lightGreen } };
            cell.font = { color: { argb: colors.primaryGreen }, bold: true };
          } else if (property.overallVacancy <= 15) {
            cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFF4E5' } };
            cell.font = { color: { argb: 'FFF59E0B' }, bold: true };
          } else {
            cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.lightRed } };
            cell.font = { color: { argb: 'FFDC2626' }, bold: true };
          }
        }
      }

      // Color code optimization potential
      if (colNumber === 6 && property.optimizationPotential > 0) {
        cell.font = { color: { argb: colors.primaryGreen }, bold: true };
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.lightGreen } };
      }

      // Color code performance score
      if (colNumber === 12) {
        if (property.performanceScore > 80) {
          cell.font = { color: { argb: colors.primaryGreen }, bold: true };
        } else if (property.performanceScore < 60) {
          cell.font = { color: { argb: 'FFDC2626' }, bold: true };
        }
      }
    });
  });

  // Summary totals
  worksheet.addRow([]);
  const totalsHeaderRow = worksheet.addRow(['Portfolio Totals']);
  totalsHeaderRow.getCell(1).font = { size: 14, bold: true, color: { argb: colors.primaryGreen } };

  const totalCurrentRevenue = data.propertyPerformance.reduce((sum, p) => sum + p.currentMonthlyRevenue, 0);
  const totalOptimizedRevenue = data.propertyPerformance.reduce((sum, p) => sum + p.optimizedMonthlyRevenue, 0);
  const totalPotential = data.propertyPerformance.reduce((sum, p) => sum + p.optimizationPotential, 0);

  // Calculate portfolio-wide average rent per unit
  const totalOccupiedUnits = data.propertyPerformance.reduce((sum, p) => 
    sum + (p.totalUnits * (p.occupancyRate / 100)), 0
  );
  const portfolioAvgRent = totalOccupiedUnits > 0 ? totalCurrentRevenue / totalOccupiedUnits : 0;
  
  const totalsData = [
    ['', '', data.portfolioSummary.totalUnits, totalCurrentRevenue, totalOptimizedRevenue, totalPotential, totalPotential * 12, '', portfolioAvgRent, '']
  ];

  totalsData.forEach((row) => {
    const excelRow = worksheet.addRow(row);
    excelRow.eachCell((cell, colNumber) => {
      if ([3, 4, 5, 6, 7].includes(colNumber) && cell.value !== '') {
        cell.font = { bold: true, color: { argb: colors.primaryBlue } };
        if ([4, 5, 6, 7].includes(colNumber)) {
          cell.numFmt = '"$"#,##0.00';
        }
      }
    });
  });

  // Set column widths
  worksheet.columns = [
    { width: 25 }, // Property Name
    { width: 30 }, // Address
    { width: 10 }, // Units
    { width: 15 }, // Current Revenue
    { width: 15 }, // Optimized Revenue
    { width: 15 }, // Monthly Potential
    { width: 15 }, // Annual Potential
    { width: 12 }, // Occupancy %
    { width: 12 }, // Vacancy %
    { width: 12 }, // Vacant Units
    { width: 15 }, // Avg Rent/Unit
    { width: 15 }  // Performance Score
  ];
}

async function createPerformanceSheet(workbook: ExcelJS.Workbook, data: PortfolioExportData, colors: any) {
  const worksheet = workbook.addWorksheet('Performance Analytics');

  // Title
  const titleRow = worksheet.addRow(['Portfolio Performance Analytics']);
  titleRow.getCell(1).font = { size: 18, bold: true, color: { argb: colors.primaryBlue } };
  titleRow.height = 30;
  
  worksheet.addRow(['Performance Period:', 'Last 12 Months']);
  worksheet.addRow([]);

  // Performance Metrics
  const metricsHeader = worksheet.addRow(['Key Performance Indicators']);
  metricsHeader.getCell(1).font = { size: 14, bold: true, color: { argb: colors.primaryGreen } };
  worksheet.addRow([]);

  if (data.trends) {
    const kpiData = [
      ['Metric', 'Value', 'Trend', 'Industry Benchmark'],
      ['Revenue Growth', `${data.trends.revenueGrowth.toFixed(1)}%`, 'Positive', '6.5%'],
      ['Occupancy Trend', `+${data.trends.occupancyTrend.toFixed(1)}%`, 'Improving', '+1.2%'],
      ['Rent Growth', `${data.trends.rentGrowth.toFixed(1)}%`, 'Strong', '4.2%'],
      ['Optimization Success Rate', `${data.trends.optimizationSuccessRate.toFixed(1)}%`, 'Excellent', '75.0%']
    ];

    kpiData.forEach((row, index) => {
      const excelRow = worksheet.addRow(row);
      if (index === 0) {
        // Header row
        excelRow.eachCell((cell) => {
          cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
          cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.primaryBlue } };
          cell.border = {
            top: { style: 'thin' }, left: { style: 'thin' },
            bottom: { style: 'thin' }, right: { style: 'thin' }
          };
          cell.alignment = { horizontal: 'center', vertical: 'middle' };
        });
      } else {
        // Data rows
        excelRow.eachCell((cell, colNumber) => {
          if (colNumber === 1) {
            cell.font = { bold: true };
          }
          if (colNumber === 3) {
            // Color code trends
            const trend = row[2];
            if (trend === 'Positive' || trend === 'Improving' || trend === 'Strong' || trend === 'Excellent') {
              cell.font = { color: { argb: colors.primaryGreen }, bold: true };
            }
          }
          cell.border = {
            top: { style: 'thin' }, left: { style: 'thin' },
            bottom: { style: 'thin' }, right: { style: 'thin' }
          };
        });
      }
    });
  }

  worksheet.addRow([]);

  // Top and Bottom Performers
  const topPerformersHeader = worksheet.addRow(['Top Performing Properties']);
  topPerformersHeader.getCell(1).font = { size: 14, bold: true, color: { argb: colors.primaryGreen } };
  worksheet.addRow([]);

  const sortedProperties = [...data.propertyPerformance]
    .sort((a, b) => b.performanceScore - a.performanceScore)
    .slice(0, 5);

  const performersHeaderRow = worksheet.addRow(['Rank', 'Property Name', 'Performance Score', 'Optimization Potential', 'Occupancy Rate']);
  performersHeaderRow.eachCell((cell) => {
    cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.primaryBlue } };
    cell.border = {
      top: { style: 'thin' }, left: { style: 'thin' },
      bottom: { style: 'thin' }, right: { style: 'thin' }
    };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
  });

  sortedProperties.forEach((property, index) => {
    const row = worksheet.addRow([
      index + 1,
      property.propertyName || 'Unknown',
      (property.performanceScore || 0).toFixed(1),
      property.optimizationPotential || 0,
      (property.occupancyRate || 0).toFixed(1)
    ]);

    row.eachCell((cell, colNumber) => {
      cell.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };

      if (colNumber === 4) {
        cell.numFmt = '"$"#,##0.00';
      }
      if (colNumber === 5) {
        cell.numFmt = '0.0"%"';
      }
      
      // Highlight top performer
      if (index === 0) {
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.lightGreen } };
      }
    });
  });

  // Set column widths
  worksheet.columns = [
    { width: 20 }, // Metric/Rank
    { width: 25 }, // Value/Property Name
    { width: 15 }, // Trend/Performance Score
    { width: 20 }  // Benchmark/Optimization Potential
  ];
}

async function createVacancySheet(workbook: ExcelJS.Workbook, data: PortfolioExportData, colors: any) {
  const worksheet = workbook.addWorksheet('Vacancy Metrics');

  // Title
  const titleRow = worksheet.addRow(['Portfolio Vacancy Analysis']);
  titleRow.getCell(1).font = { size: 18, bold: true, color: { argb: colors.primaryBlue } };
  titleRow.height = 30;
  
  worksheet.addRow(['Analysis Date:', new Date().toLocaleDateString()]);
  worksheet.addRow([]);

  if (!data.vacancyMetrics) {
    const noDataRow = worksheet.addRow(['Vacancy data not available']);
    noDataRow.getCell(1).font = { italic: true, color: { argb: colors.lightGray } };
    return;
  }

  // Portfolio Summary Section
  const summaryHeader = worksheet.addRow(['Portfolio Vacancy Summary']);
  summaryHeader.getCell(1).font = { size: 14, bold: true, color: { argb: colors.primaryGreen } };
  worksheet.addRow([]);

  const summaryData = [
    ['Metric', 'Value', 'Status'],
    ['Overall Portfolio Vacancy', `${data.vacancyMetrics.portfolioVacancy.overallVacancy.toFixed(1)}%`,
      data.vacancyMetrics.portfolioVacancy.overallVacancy < 5 ? 'Excellent' :
      data.vacancyMetrics.portfolioVacancy.overallVacancy < 15 ? 'Good' : 'Needs Attention'],
    ['Total Units', data.vacancyMetrics.portfolioVacancy.totalUnits, ''],
    ['Vacant Units', data.vacancyMetrics.portfolioVacancy.vacantUnits, ''],
    ['Market Position', data.vacancyMetrics.marketPosition || 'N/A', ''],
    ['Competitor Avg Vacancy', data.vacancyMetrics.competitorAvgVacancy !== undefined ? 
      `${data.vacancyMetrics.competitorAvgVacancy.toFixed(1)}%` : 'N/A', '']
  ];

  summaryData.forEach((row, index) => {
    const excelRow = worksheet.addRow(row);
    if (index === 0) {
      // Header row
      excelRow.eachCell((cell) => {
        cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.primaryBlue } };
        cell.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
      });
    } else {
      // Data rows
      excelRow.eachCell((cell, colNumber) => {
        if (colNumber === 1) {
          cell.font = { bold: true };
        }
        cell.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
      });
    }
  });

  worksheet.addRow([]);
  worksheet.addRow([]);

  // Vacancy by Bedroom Type Section
  const bedroomHeader = worksheet.addRow(['Vacancy by Bedroom Type']);
  bedroomHeader.getCell(1).font = { size: 14, bold: true, color: { argb: colors.primaryGreen } };
  worksheet.addRow([]);

  const bedroomData = [
    ['Bedroom Type', 'Portfolio Vacancy %', 'Status'],
    ['Studio', 
      data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.studio !== null ?
        `${data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.studio.toFixed(1)}%` : 'N/A',
      data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.studio !== null ?
        (data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.studio < 5 ? 'Low' :
         data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.studio < 15 ? 'Moderate' : 'High') : ''],
    ['1 Bedroom',
      data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.oneBedroom !== null ?
        `${data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.oneBedroom.toFixed(1)}%` : 'N/A',
      data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.oneBedroom !== null ?
        (data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.oneBedroom < 5 ? 'Low' :
         data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.oneBedroom < 15 ? 'Moderate' : 'High') : ''],
    ['2 Bedroom',
      data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.twoBedroom !== null ?
        `${data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.twoBedroom.toFixed(1)}%` : 'N/A',
      data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.twoBedroom !== null ?
        (data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.twoBedroom < 5 ? 'Low' :
         data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.twoBedroom < 15 ? 'Moderate' : 'High') : ''],
    ['3 Bedroom',
      data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.threeBedroom !== null ?
        `${data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.threeBedroom.toFixed(1)}%` : 'N/A',
      data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.threeBedroom !== null ?
        (data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.threeBedroom < 5 ? 'Low' :
         data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.threeBedroom < 15 ? 'Moderate' : 'High') : ''],
    ['4+ Bedroom',
      data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.fourPlusBedroom !== null ?
        `${data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.fourPlusBedroom.toFixed(1)}%` : 'N/A',
      data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.fourPlusBedroom !== null ?
        (data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.fourPlusBedroom < 5 ? 'Low' :
         data.vacancyMetrics.portfolioVacancy.vacancyByBedroom.fourPlusBedroom < 15 ? 'Moderate' : 'High') : '']
  ];

  bedroomData.forEach((row, index) => {
    const excelRow = worksheet.addRow(row);
    if (index === 0) {
      // Header row
      excelRow.eachCell((cell) => {
        cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.primaryBlue } };
        cell.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
      });
    } else {
      // Data rows
      excelRow.eachCell((cell, colNumber) => {
        if (colNumber === 1) {
          cell.font = { bold: true };
        }
        // Apply conditional formatting to vacancy percentage column
        if (colNumber === 2 && cell.value !== 'N/A' && typeof row[1] === 'string') {
          const vacancyValue = parseFloat(row[1].replace('%', ''));
          if (vacancyValue <= 5) {
            cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.lightGreen } };
            cell.font = { color: { argb: colors.primaryGreen }, bold: true };
          } else if (vacancyValue <= 15) {
            cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFF4E5' } };
            cell.font = { color: { argb: 'FFF59E0B' }, bold: true };
          } else {
            cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.lightRed } };
            cell.font = { color: { argb: 'FFDC2626' }, bold: true };
          }
        }
        cell.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
      });
    }
  });

  worksheet.addRow([]);
  worksheet.addRow([]);

  // Property-by-Property Vacancy Details
  const propertyHeader = worksheet.addRow(['Property Vacancy Details']);
  propertyHeader.getCell(1).font = { size: 14, bold: true, color: { argb: colors.primaryGreen } };
  worksheet.addRow([]);

  const propertyHeaderRow = worksheet.addRow([
    'Property Name',
    'Total Units',
    'Vacant Units',
    'Overall Vacancy %',
    'Studio %',
    '1BR %',
    '2BR %',
    '3BR %',
    '4BR+ %'
  ]);

  propertyHeaderRow.eachCell((cell) => {
    cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.primaryBlue } };
    cell.border = {
      top: { style: 'thin' }, left: { style: 'thin' },
      bottom: { style: 'thin' }, right: { style: 'thin' }
    };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
  });

  // Add property data
  data.vacancyMetrics.propertyVacancies.forEach((property) => {
    const row = worksheet.addRow([
      property.propertyName,
      property.totalUnits,
      property.vacantUnits,
      property.overallVacancy,
      property.vacancyByBedroom.studio !== null ? property.vacancyByBedroom.studio : 'N/A',
      property.vacancyByBedroom.oneBedroom !== null ? property.vacancyByBedroom.oneBedroom : 'N/A',
      property.vacancyByBedroom.twoBedroom !== null ? property.vacancyByBedroom.twoBedroom : 'N/A',
      property.vacancyByBedroom.threeBedroom !== null ? property.vacancyByBedroom.threeBedroom : 'N/A',
      property.vacancyByBedroom.fourPlusBedroom !== null ? property.vacancyByBedroom.fourPlusBedroom : 'N/A'
    ]);

    row.eachCell((cell, colNumber) => {
      cell.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };

      // Format percentage columns
      if (colNumber >= 4 && typeof cell.value === 'number') {
        cell.numFmt = '0.0"%"';

        // Apply conditional formatting to overall vacancy
        if (colNumber === 4) {
          if (property.overallVacancy <= 5) {
            cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.lightGreen } };
            cell.font = { color: { argb: colors.primaryGreen }, bold: true };
          } else if (property.overallVacancy <= 15) {
            cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFF4E5' } };
            cell.font = { color: { argb: 'FFF59E0B' }, bold: true };
          } else {
            cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.lightRed } };
            cell.font = { color: { argb: 'FFDC2626' }, bold: true };
          }
        }
      }
    });
  });

  // Set column widths
  worksheet.columns = [
    { width: 25 }, // Property Name
    { width: 12 }, // Total Units
    { width: 12 }, // Vacant Units
    { width: 15 }, // Overall Vacancy %
    { width: 10 }, // Studio %
    { width: 10 }, // 1BR %
    { width: 10 }, // 2BR %
    { width: 10 }, // 3BR %
    { width: 10 }  // 4BR+ %
  ];
}

async function createInsightsSheet(workbook: ExcelJS.Workbook, data: PortfolioExportData, colors: any) {
  const worksheet = workbook.addWorksheet('Strategic Insights');

  // Title
  const titleRow = worksheet.addRow(['Portfolio Strategic Insights & Recommendations']);
  titleRow.getCell(1).font = { size: 18, bold: true, color: { argb: colors.primaryBlue } };
  titleRow.height = 30;
  
  worksheet.addRow(['Generated:', new Date().toLocaleDateString()]);
  worksheet.addRow([]);

  if (!data.insights || !data.insights.strategicRecommendations) {
    const noDataRow = worksheet.addRow(['No strategic insights available']);
    noDataRow.getCell(1).font = { italic: true, color: { argb: colors.lightGray } };
    return;
  }

  // Strategic Recommendations
  const recommendationsHeader = worksheet.addRow(['Strategic Recommendations']);
  recommendationsHeader.getCell(1).font = { size: 16, bold: true, color: { argb: colors.primaryGreen } };
  worksheet.addRow([]);

  data.insights.strategicRecommendations.forEach((recommendation, index) => {
    const categoryRow = worksheet.addRow([`${index + 1}. ${recommendation.category} (${recommendation.priority} Priority)`]);
    categoryRow.getCell(1).font = { size: 12, bold: true, color: { argb: colors.darkGray } };
    
    const insightRow = worksheet.addRow(['', recommendation.insight]);
    insightRow.getCell(2).alignment = { wrapText: true };
    
    worksheet.addRow(['', 'Action Items:']);
    recommendation.actionItems.forEach(action => {
      const actionRow = worksheet.addRow(['', `• ${action}`]);
      actionRow.getCell(2).alignment = { wrapText: true };
    });
    
    worksheet.addRow([]);
  });

  // Risk Assessment
  const riskHeader = worksheet.addRow(['Risk Assessment']);
  riskHeader.getCell(1).font = { size: 16, bold: true, color: { argb: colors.primaryGreen } };
  worksheet.addRow([]);

  const riskLevelRow = worksheet.addRow(['Overall Risk Level:', data.insights.riskAssessment.overallRiskLevel]);
  riskLevelRow.getCell(1).font = { bold: true };
  riskLevelRow.getCell(2).font = { 
    bold: true, 
    color: { 
      argb: data.insights.riskAssessment.overallRiskLevel === 'Low' ? colors.primaryGreen :
            data.insights.riskAssessment.overallRiskLevel === 'Medium' ? '#FFA500' : '#FF0000'
    }
  };

  worksheet.addRow([]);
  worksheet.addRow(['Risk Mitigation Recommendations:']);
  
  data.insights.riskAssessment.recommendations.forEach(recommendation => {
    const recRow = worksheet.addRow(['', `• ${recommendation}`]);
    recRow.getCell(2).alignment = { wrapText: true };
  });

  // Set column widths
  worksheet.columns = [
    { width: 25 }, // Category/Label
    { width: 80 }  // Content
  ];
}