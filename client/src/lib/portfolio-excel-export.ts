import ExcelJS from 'exceljs';

export interface PortfolioExportData {
  portfolioSummary: {
    totalProperties: number;
    totalUnits: number;
    totalCurrentRevenue: number;
    totalOptimizedRevenue: number;
    totalOptimizationPotential: number;
    annualOptimizationPotential: number;
    avgPerformanceScore: number;
    portfolioROI: number;
    avgOccupancyRate: number;
    generatedAt: string;
  };
  propertyPerformance: Array<{
    propertyId: string;
    propertyName: string;
    address: string;
    totalUnits: number;
    currentMonthlyRevenue: number;
    optimizedMonthlyRevenue: number;
    optimizationPotential: number;
    annualOptimizationPotential: number;
    occupancyRate: number;
    performanceScore: number;
    lastAnalyzed: Date | string;
  }>;
  trends?: {
    revenueGrowth: number;
    occupancyTrend: number;
    rentGrowth: number;
    optimizationSuccessRate: number;
  };
  insights?: {
    strategicRecommendations: Array<{
      category: string;
      priority: string;
      insight: string;
      actionItems: string[];
    }>;
    riskAssessment: {
      overallRiskLevel: string;
      recommendations: string[];
    };
  };
}

export async function exportPortfolioToExcel(
  data: PortfolioExportData, 
  reportType: 'summary' | 'financial' | 'performance' | 'executive'
): Promise<void> {
  // Validate required data
  if (!data.portfolioSummary) {
    throw new Error('Portfolio summary data is required for export');
  }
  
  if (!data.propertyPerformance || data.propertyPerformance.length === 0) {
    throw new Error('Property performance data is required for export');
  }
  const workbook = new ExcelJS.Workbook();
  workbook.creator = 'PropertyAnalytics Pro';
  workbook.lastModifiedBy = 'PropertyAnalytics Pro';
  workbook.created = new Date();
  workbook.modified = new Date();
  
  // Define common colors for branding
  const colors = {
    primaryBlue: 'FF2563EB',
    primaryGreen: 'FF059669',
    lightBlue: 'FFE0F2FE',
    lightGreen: 'FFDCFCE7',
    lightRed: 'FFFEF2F2',
    darkGray: 'FF374151',
    lightGray: 'FF9CA3AF'
  };

  if (reportType === 'summary' || reportType === 'executive') {
    await createSummarySheet(workbook, data, colors);
  }
  
  if (reportType === 'financial' || reportType === 'executive') {
    await createFinancialSheet(workbook, data, colors);
  }
  
  if (reportType === 'performance' || reportType === 'executive') {
    await createPerformanceSheet(workbook, data, colors);
  }
  
  if (reportType === 'executive' && data.insights) {
    await createInsightsSheet(workbook, data, colors);
  }

  // Generate and download the file
  const buffer = await workbook.xlsx.writeBuffer();
  const blob = new Blob([buffer], { 
    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
  });
  
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.href = url;
  
  const timestamp = new Date().toISOString().split('T')[0];
  const filename = `portfolio-${reportType}-report-${timestamp}.xlsx`;
  link.download = filename;
  
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

async function createSummarySheet(workbook: ExcelJS.Workbook, data: PortfolioExportData, colors: any) {
  const worksheet = workbook.addWorksheet('Portfolio Summary', {
    headerFooter: {
      firstHeader: 'Portfolio Summary Report',
      firstFooter: '&CGenerated by PropertyAnalytics Pro'
    }
  });

  // Title Section
  const titleRow = worksheet.addRow(['Portfolio Summary Report']);
  titleRow.getCell(1).font = { size: 20, bold: true, color: { argb: colors.primaryBlue } };
  titleRow.height = 35;
  
  worksheet.addRow(['Generated on:', new Date().toLocaleDateString()]);
  worksheet.addRow(['Report Period:', 'Current Portfolio Status']);
  worksheet.addRow([]);

  // Portfolio Overview Section
  const overviewHeader = worksheet.addRow(['Portfolio Overview']);
  overviewHeader.getCell(1).font = { size: 16, bold: true, color: { argb: colors.primaryGreen } };
  worksheet.addRow([]);

  const overviewData = [
    ['Metric', 'Value', 'Performance'],
    ['Total Properties', data.portfolioSummary.totalProperties, ''],
    ['Total Units', data.portfolioSummary.totalUnits, ''],
    ['Current Monthly Revenue', `$${data.portfolioSummary.totalCurrentRevenue.toLocaleString()}`, ''],
    ['Optimized Monthly Revenue', `$${data.portfolioSummary.totalOptimizedRevenue.toLocaleString()}`, ''],
    ['Monthly Optimization Potential', `$${data.portfolioSummary.totalOptimizationPotential.toLocaleString()}`, ''],
    ['Annual Optimization Potential', `$${data.portfolioSummary.annualOptimizationPotential.toLocaleString()}`, ''],
    ['Average Occupancy Rate', `${data.portfolioSummary.avgOccupancyRate.toFixed(1)}%`, data.portfolioSummary.avgOccupancyRate > 85 ? 'Excellent' : data.portfolioSummary.avgOccupancyRate > 75 ? 'Good' : 'Needs Attention'],
    ['Portfolio ROI', `${data.portfolioSummary.portfolioROI.toFixed(1)}%`, data.portfolioSummary.portfolioROI > 12 ? 'Above Average' : 'Market Rate'],
    ['Average Performance Score', `${data.portfolioSummary.avgPerformanceScore.toFixed(0)}/100`, data.portfolioSummary.avgPerformanceScore > 80 ? 'Excellent' : data.portfolioSummary.avgPerformanceScore > 70 ? 'Good' : 'Needs Improvement']
  ];

  let startRow = worksheet.rowCount + 1;
  overviewData.forEach((row, index) => {
    const excelRow = worksheet.addRow(row);
    if (index === 0) {
      // Header row
      excelRow.eachCell((cell) => {
        cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.primaryBlue } };
        cell.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
      });
    } else {
      // Data rows
      excelRow.eachCell((cell, colNumber) => {
        if (colNumber === 1) {
          cell.font = { bold: true };
        }
        if (colNumber === 2 && typeof row[1] === 'string' && row[1].startsWith('$')) {
          cell.font = { color: { argb: colors.primaryGreen }, bold: true };
        }
        cell.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
      });
    }
  });

  // Set column widths
  worksheet.columns = [
    { width: 30 }, // Metric
    { width: 25 }, // Value
    { width: 20 }  // Performance
  ];

  worksheet.addRow([]);
}

async function createFinancialSheet(workbook: ExcelJS.Workbook, data: PortfolioExportData, colors: any) {
  const worksheet = workbook.addWorksheet('Financial Analysis');

  // Title
  const titleRow = worksheet.addRow(['Portfolio Financial Analysis']);
  titleRow.getCell(1).font = { size: 18, bold: true, color: { argb: colors.primaryBlue } };
  titleRow.height = 30;
  
  worksheet.addRow(['As of:', new Date().toLocaleDateString()]);
  worksheet.addRow([]);

  // Property-by-Property Financial Performance
  const headerRow = worksheet.addRow([
    'Property Name',
    'Address',
    'Units',
    'Current Revenue',
    'Optimized Revenue',
    'Monthly Potential',
    'Annual Potential',
    'Occupancy %',
    'Avg Rent/Unit',
    'Performance Score'
  ]);

  // Style header row
  headerRow.eachCell((cell) => {
    cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.primaryBlue } };
    cell.border = {
      top: { style: 'thin' }, left: { style: 'thin' },
      bottom: { style: 'thin' }, right: { style: 'thin' }
    };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
  });

  // Add property data with safe property access and calculated avgRentPerUnit
  data.propertyPerformance.forEach((property) => {
    // Calculate avgRentPerUnit from currentMonthlyRevenue and occupied units estimate
    const avgRentPerUnit = property.totalUnits > 0 ? 
      property.currentMonthlyRevenue / (property.totalUnits * (property.occupancyRate / 100)) : 0;
    
    const row = worksheet.addRow([
      property.propertyName || 'Unknown',
      property.address || 'N/A',
      property.totalUnits || 0,
      property.currentMonthlyRevenue || 0,
      property.optimizedMonthlyRevenue || 0,
      property.optimizationPotential || 0,
      property.annualOptimizationPotential || 0,
      property.occupancyRate || 0,
      avgRentPerUnit,
      property.performanceScore || 0
    ]);

    // Apply conditional formatting
    row.eachCell((cell, colNumber) => {
      cell.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };

      // Format currency columns
      if ([4, 5, 6, 7, 9].includes(colNumber)) {
        cell.numFmt = '"$"#,##0.00';
      }
      
      // Format percentage columns
      if (colNumber === 8) {
        cell.numFmt = '0.0"%"';
      }

      // Color code optimization potential
      if (colNumber === 6 && property.optimizationPotential > 0) {
        cell.font = { color: { argb: colors.primaryGreen }, bold: true };
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.lightGreen } };
      }

      // Color code performance score
      if (colNumber === 10) {
        if (property.performanceScore > 80) {
          cell.font = { color: { argb: colors.primaryGreen }, bold: true };
        } else if (property.performanceScore < 60) {
          cell.font = { color: { argb: 'FFDC2626' }, bold: true };
        }
      }
    });
  });

  // Summary totals
  worksheet.addRow([]);
  const totalsHeaderRow = worksheet.addRow(['Portfolio Totals']);
  totalsHeaderRow.getCell(1).font = { size: 14, bold: true, color: { argb: colors.primaryGreen } };

  const totalCurrentRevenue = data.propertyPerformance.reduce((sum, p) => sum + p.currentMonthlyRevenue, 0);
  const totalOptimizedRevenue = data.propertyPerformance.reduce((sum, p) => sum + p.optimizedMonthlyRevenue, 0);
  const totalPotential = data.propertyPerformance.reduce((sum, p) => sum + p.optimizationPotential, 0);

  // Calculate portfolio-wide average rent per unit
  const totalOccupiedUnits = data.propertyPerformance.reduce((sum, p) => 
    sum + (p.totalUnits * (p.occupancyRate / 100)), 0
  );
  const portfolioAvgRent = totalOccupiedUnits > 0 ? totalCurrentRevenue / totalOccupiedUnits : 0;
  
  const totalsData = [
    ['', '', data.portfolioSummary.totalUnits, totalCurrentRevenue, totalOptimizedRevenue, totalPotential, totalPotential * 12, '', portfolioAvgRent, '']
  ];

  totalsData.forEach((row) => {
    const excelRow = worksheet.addRow(row);
    excelRow.eachCell((cell, colNumber) => {
      if ([3, 4, 5, 6, 7].includes(colNumber) && cell.value !== '') {
        cell.font = { bold: true, color: { argb: colors.primaryBlue } };
        if ([4, 5, 6, 7].includes(colNumber)) {
          cell.numFmt = '"$"#,##0.00';
        }
      }
    });
  });

  // Set column widths
  worksheet.columns = [
    { width: 25 }, // Property Name
    { width: 30 }, // Address
    { width: 10 }, // Units
    { width: 15 }, // Current Revenue
    { width: 15 }, // Optimized Revenue
    { width: 15 }, // Monthly Potential
    { width: 15 }, // Annual Potential
    { width: 12 }, // Occupancy %
    { width: 15 }, // Avg Rent/Unit
    { width: 15 }  // Performance Score
  ];
}

async function createPerformanceSheet(workbook: ExcelJS.Workbook, data: PortfolioExportData, colors: any) {
  const worksheet = workbook.addWorksheet('Performance Analytics');

  // Title
  const titleRow = worksheet.addRow(['Portfolio Performance Analytics']);
  titleRow.getCell(1).font = { size: 18, bold: true, color: { argb: colors.primaryBlue } };
  titleRow.height = 30;
  
  worksheet.addRow(['Performance Period:', 'Last 12 Months']);
  worksheet.addRow([]);

  // Performance Metrics
  const metricsHeader = worksheet.addRow(['Key Performance Indicators']);
  metricsHeader.getCell(1).font = { size: 14, bold: true, color: { argb: colors.primaryGreen } };
  worksheet.addRow([]);

  if (data.trends) {
    const kpiData = [
      ['Metric', 'Value', 'Trend', 'Industry Benchmark'],
      ['Revenue Growth', `${data.trends.revenueGrowth.toFixed(1)}%`, 'Positive', '6.5%'],
      ['Occupancy Trend', `+${data.trends.occupancyTrend.toFixed(1)}%`, 'Improving', '+1.2%'],
      ['Rent Growth', `${data.trends.rentGrowth.toFixed(1)}%`, 'Strong', '4.2%'],
      ['Optimization Success Rate', `${data.trends.optimizationSuccessRate.toFixed(1)}%`, 'Excellent', '75.0%']
    ];

    kpiData.forEach((row, index) => {
      const excelRow = worksheet.addRow(row);
      if (index === 0) {
        // Header row
        excelRow.eachCell((cell) => {
          cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
          cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.primaryBlue } };
          cell.border = {
            top: { style: 'thin' }, left: { style: 'thin' },
            bottom: { style: 'thin' }, right: { style: 'thin' }
          };
          cell.alignment = { horizontal: 'center', vertical: 'middle' };
        });
      } else {
        // Data rows
        excelRow.eachCell((cell, colNumber) => {
          if (colNumber === 1) {
            cell.font = { bold: true };
          }
          if (colNumber === 3) {
            // Color code trends
            const trend = row[2];
            if (trend === 'Positive' || trend === 'Improving' || trend === 'Strong' || trend === 'Excellent') {
              cell.font = { color: { argb: colors.primaryGreen }, bold: true };
            }
          }
          cell.border = {
            top: { style: 'thin' }, left: { style: 'thin' },
            bottom: { style: 'thin' }, right: { style: 'thin' }
          };
        });
      }
    });
  }

  worksheet.addRow([]);

  // Top and Bottom Performers
  const topPerformersHeader = worksheet.addRow(['Top Performing Properties']);
  topPerformersHeader.getCell(1).font = { size: 14, bold: true, color: { argb: colors.primaryGreen } };
  worksheet.addRow([]);

  const sortedProperties = [...data.propertyPerformance]
    .sort((a, b) => b.performanceScore - a.performanceScore)
    .slice(0, 5);

  const performersHeaderRow = worksheet.addRow(['Rank', 'Property Name', 'Performance Score', 'Optimization Potential', 'Occupancy Rate']);
  performersHeaderRow.eachCell((cell) => {
    cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.primaryBlue } };
    cell.border = {
      top: { style: 'thin' }, left: { style: 'thin' },
      bottom: { style: 'thin' }, right: { style: 'thin' }
    };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
  });

  sortedProperties.forEach((property, index) => {
    const row = worksheet.addRow([
      index + 1,
      property.propertyName || 'Unknown',
      (property.performanceScore || 0).toFixed(1),
      property.optimizationPotential || 0,
      (property.occupancyRate || 0).toFixed(1)
    ]);

    row.eachCell((cell, colNumber) => {
      cell.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };

      if (colNumber === 4) {
        cell.numFmt = '"$"#,##0.00';
      }
      if (colNumber === 5) {
        cell.numFmt = '0.0"%"';
      }
      
      // Highlight top performer
      if (index === 0) {
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.lightGreen } };
      }
    });
  });

  // Set column widths
  worksheet.columns = [
    { width: 20 }, // Metric/Rank
    { width: 25 }, // Value/Property Name
    { width: 15 }, // Trend/Performance Score
    { width: 20 }  // Benchmark/Optimization Potential
  ];
}

async function createInsightsSheet(workbook: ExcelJS.Workbook, data: PortfolioExportData, colors: any) {
  const worksheet = workbook.addWorksheet('Strategic Insights');

  // Title
  const titleRow = worksheet.addRow(['Portfolio Strategic Insights & Recommendations']);
  titleRow.getCell(1).font = { size: 18, bold: true, color: { argb: colors.primaryBlue } };
  titleRow.height = 30;
  
  worksheet.addRow(['Generated:', new Date().toLocaleDateString()]);
  worksheet.addRow([]);

  if (!data.insights || !data.insights.strategicRecommendations) {
    const noDataRow = worksheet.addRow(['No strategic insights available']);
    noDataRow.getCell(1).font = { italic: true, color: { argb: colors.lightGray } };
    return;
  }

  // Strategic Recommendations
  const recommendationsHeader = worksheet.addRow(['Strategic Recommendations']);
  recommendationsHeader.getCell(1).font = { size: 16, bold: true, color: { argb: colors.primaryGreen } };
  worksheet.addRow([]);

  data.insights.strategicRecommendations.forEach((recommendation, index) => {
    const categoryRow = worksheet.addRow([`${index + 1}. ${recommendation.category} (${recommendation.priority} Priority)`]);
    categoryRow.getCell(1).font = { size: 12, bold: true, color: { argb: colors.darkGray } };
    
    const insightRow = worksheet.addRow(['', recommendation.insight]);
    insightRow.getCell(2).alignment = { wrapText: true };
    
    worksheet.addRow(['', 'Action Items:']);
    recommendation.actionItems.forEach(action => {
      const actionRow = worksheet.addRow(['', `• ${action}`]);
      actionRow.getCell(2).alignment = { wrapText: true };
    });
    
    worksheet.addRow([]);
  });

  // Risk Assessment
  const riskHeader = worksheet.addRow(['Risk Assessment']);
  riskHeader.getCell(1).font = { size: 16, bold: true, color: { argb: colors.primaryGreen } };
  worksheet.addRow([]);

  const riskLevelRow = worksheet.addRow(['Overall Risk Level:', data.insights.riskAssessment.overallRiskLevel]);
  riskLevelRow.getCell(1).font = { bold: true };
  riskLevelRow.getCell(2).font = { 
    bold: true, 
    color: { 
      argb: data.insights.riskAssessment.overallRiskLevel === 'Low' ? colors.primaryGreen :
            data.insights.riskAssessment.overallRiskLevel === 'Medium' ? '#FFA500' : '#FF0000'
    }
  };

  worksheet.addRow([]);
  worksheet.addRow(['Risk Mitigation Recommendations:']);
  
  data.insights.riskAssessment.recommendations.forEach(recommendation => {
    const recRow = worksheet.addRow(['', `• ${recommendation}`]);
    recRow.getCell(2).alignment = { wrapText: true };
  });

  // Set column widths
  worksheet.columns = [
    { width: 25 }, // Category/Label
    { width: 80 }  // Content
  ];
}