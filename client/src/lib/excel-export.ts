import ExcelJS from 'exceljs';
import { formatCurrency } from '@/utils/formatters';

// Helper function to format square footage
function formatSquareFootage(sqft: number | undefined | null): string {
  if (sqft === undefined || sqft === null) {
    return '-';
  }
  
  // Format with comma separator and add "sq ft" suffix
  return sqft.toLocaleString() + ' sq ft';
}

export interface ExcelExportData {
  propertyInfo: {
    address: string;
    type: string;
    units: number;
    builtYear: number;
  };
  units: Array<{
    propertyName?: string;
    unitNumber: string;
    tag?: string;
    bedrooms?: number;
    bathrooms?: number;
    unitType: string;
    squareFootage?: number;
    currentRent: number;
    recommendedRent?: number;
    change: number;
    annualImpact: number;
    status: string;
    reasoning?: string;
  }>;
  summary: {
    totalIncrease: number;
    affectedUnits: number;
    avgIncrease: number;
    riskLevel: string;
  };
  marketInsights?: {
    occupancyImpact: string;
    competitivePosition: string;
    timeToLease: string;
  };
}

export async function exportToExcel(data: ExcelExportData): Promise<void> {
  const workbook = new ExcelJS.Workbook();
  workbook.creator = 'Property Optimization Tool';
  workbook.lastModifiedBy = 'Property Optimization Tool';
  workbook.created = new Date();
  workbook.modified = new Date();
  
  // Create main worksheet
  const worksheet = workbook.addWorksheet('Optimization Report', {
    headerFooter: {
      firstHeader: 'Property Optimization Report',
      firstFooter: '&CGenerated by Property Optimization Tool'
    }
  });
  
  // Set column widths
  worksheet.columns = [
    { header: 'Unit Number', key: 'unitNumber', width: 15 },
    { header: 'Property', key: 'propertyName', width: 20 },
    { header: 'Unit Type', key: 'unitType', width: 15 },
    { header: 'Square Footage', key: 'squareFootage', width: 15 },
    { header: 'Current Rent', key: 'currentRent', width: 15 },
    { header: 'Recommended Rent', key: 'recommendedRent', width: 18 },
    { header: 'Monthly Change', key: 'change', width: 15 },
    { header: 'Annual Impact', key: 'annualImpact', width: 15 },
    { header: 'Status', key: 'status', width: 12 },
    { header: 'Notes', key: 'notes', width: 40 }
  ];
  
  // Add title and property info
  const titleRow = worksheet.addRow(['Property Optimization Report']);
  titleRow.getCell(1).font = { size: 18, bold: true, color: { argb: 'FF2563EB' } };
  titleRow.height = 30;
  
  worksheet.addRow(['Generated on:', new Date().toLocaleDateString()]);
  worksheet.addRow([]);
  
  // Property Information Section
  const propertyHeaderRow = worksheet.addRow(['Property Information']);
  propertyHeaderRow.getCell(1).font = { size: 14, bold: true, color: { argb: 'FF059669' } };
  
  worksheet.addRow(['Address:', data.propertyInfo.address]);
  worksheet.addRow(['Property Type:', data.propertyInfo.type]);
  worksheet.addRow(['Total Units:', data.propertyInfo.units]);
  worksheet.addRow(['Built Year:', data.propertyInfo.builtYear]);
  worksheet.addRow([]);
  
  // Units Section Header
  const unitsHeaderRow = worksheet.addRow(['Unit-by-Unit Optimization']);
  unitsHeaderRow.getCell(1).font = { size: 14, bold: true, color: { argb: 'FF059669' } };
  worksheet.addRow([]);
  
  // Add header row for units table
  const headerRow = worksheet.addRow([
    'Unit Number',
    'Property',
    'Unit Type',
    'Square Footage',
    'Current Rent',
    'Recommended Rent',
    'Monthly Change',
    'Annual Impact',
    'Status',
    'Notes'
  ]);
  
  // Style header row
  headerRow.eachCell((cell) => {
    cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
    cell.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF3B82F6' }
    };
    cell.border = {
      top: { style: 'thin' },
      left: { style: 'thin' },
      bottom: { style: 'thin' },
      right: { style: 'thin' }
    };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
  });
  
  // Add unit data with conditional formatting
  data.units.forEach((unit) => {
    const row = worksheet.addRow([
      unit.unitNumber,
      unit.propertyName || '',
      unit.unitType,
      formatSquareFootage(unit.squareFootage),
      unit.currentRent,
      unit.recommendedRent || unit.currentRent,
      unit.change,
      unit.annualImpact,
      unit.status,
      unit.reasoning || 'No additional notes'
    ]);
    
    // Apply conditional formatting based on change amount
    const changeCell = row.getCell(7); // Monthly Change column (shifted by 2: Property, Square Footage)
    const impactCell = row.getCell(8); // Annual Impact column (shifted by 2: Property, Square Footage)
    
    if (unit.change > 0) {
      // Positive change - green
      changeCell.font = { color: { argb: 'FF059669' }, bold: true };
      changeCell.fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FFDCFCE7' }
      };
      impactCell.font = { color: { argb: 'FF059669' }, bold: true };
      impactCell.fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FFDCFCE7' }
      };
    } else if (unit.change < 0) {
      // Negative change - red
      changeCell.font = { color: { argb: 'FFDC2626' }, bold: true };
      changeCell.fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FFFEF2F2' }
      };
      impactCell.font = { color: { argb: 'FFDC2626' }, bold: true };
      impactCell.fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FFFEF2F2' }
      };
    } else {
      // No change - gray
      changeCell.font = { color: { argb: 'FF6B7280' } };
      impactCell.font = { color: { argb: 'FF6B7280' } };
    }
    
    // Add borders to all cells
    row.eachCell((cell) => {
      cell.border = {
        top: { style: 'thin' },
        left: { style: 'thin' },
        bottom: { style: 'thin' },
        right: { style: 'thin' }
      };
    });
    
    // Format currency cells
    row.getCell(5).numFmt = '"$"#,##0.00'; // Current Rent (shifted by 2: Property, Square Footage)
    row.getCell(6).numFmt = '"$"#,##0.00'; // Recommended Rent (shifted by 2: Property, Square Footage)
    row.getCell(7).numFmt = '"$"#,##0.00'; // Monthly Change (shifted by 2: Property, Square Footage)
    row.getCell(8).numFmt = '"$"#,##0.00'; // Annual Impact (shifted by 2: Property, Square Footage)
  });
  
  worksheet.addRow([]);
  
  // Summary Section
  const summaryHeaderRow = worksheet.addRow(['Optimization Summary']);
  summaryHeaderRow.getCell(1).font = { size: 14, bold: true, color: { argb: 'FF059669' } };
  
  const summaryData = [
    ['Total Annual Revenue Increase:', formatCurrency(data.summary.totalIncrease)],
    ['Units Affected:', data.summary.affectedUnits],
    ['Average Rent Increase:', `${data.summary.avgIncrease}%`],
    ['Risk Level:', data.summary.riskLevel]
  ];
  
  summaryData.forEach(([label, value]) => {
    const row = worksheet.addRow([label, value]);
    row.getCell(1).font = { bold: true };
    if (typeof label === 'string' && label.includes('Revenue Increase') && typeof value === 'string' && value.startsWith('$')) {
      row.getCell(2).font = { color: { argb: 'FF059669' }, bold: true };
    }
  });
  
  // Market Insights Section (if available)
  if (data.marketInsights) {
    worksheet.addRow([]);
    const insightsHeaderRow = worksheet.addRow(['Market Insights']);
    insightsHeaderRow.getCell(1).font = { size: 14, bold: true, color: { argb: 'FF059669' } };
    
    worksheet.addRow(['Occupancy Impact:', data.marketInsights.occupancyImpact]);
    worksheet.addRow(['Competitive Position:', data.marketInsights.competitivePosition]);
    worksheet.addRow(['Time to Lease:', data.marketInsights.timeToLease]);
  }
  
  // Generate and download the file
  const buffer = await workbook.xlsx.writeBuffer();
  const blob = new Blob([buffer], { 
    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
  });
  
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.href = url;
  link.download = `property-optimization-${Date.now()}.xlsx`;
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

function groupUnitsByPropertyBedroomTag(units: ExcelExportData['units']) {
  const grouped: Record<string, Record<string, Record<string, typeof units>>> = {};
  
  units.forEach(unit => {
    const propertyName = unit.propertyName || 'Unknown Property';
    const bedrooms = String(unit.bedrooms ?? 0);
    const tag = unit.tag || 'Unknown TAG';
    
    if (!grouped[propertyName]) {
      grouped[propertyName] = {};
    }
    if (!grouped[propertyName][bedrooms]) {
      grouped[propertyName][bedrooms] = {};
    }
    if (!grouped[propertyName][bedrooms][tag]) {
      grouped[propertyName][bedrooms][tag] = [];
    }
    
    grouped[propertyName][bedrooms][tag].push(unit);
  });
  
  return grouped;
}

export async function exportToExcelHierarchical(data: ExcelExportData): Promise<void> {
  // Fetch tag definitions for proper sorting
  let tagOrderMap = new Map<string, number>();
  try {
    const response = await fetch('/api/tag-definitions');
    if (response.ok) {
      const tagDefinitions = await response.json();
      for (const tagDef of tagDefinitions) {
        tagOrderMap.set(tagDef.tag, tagDef.displayOrder);
      }
    }
  } catch (error) {
    console.warn('Failed to fetch tag definitions, using alphabetic sorting as fallback:', error);
  }
  
  const workbook = new ExcelJS.Workbook();
  workbook.creator = 'Property Optimization Tool';
  workbook.lastModifiedBy = 'Property Optimization Tool';
  workbook.created = new Date();
  workbook.modified = new Date();
  
  const worksheet = workbook.addWorksheet('Optimization Report', {
    headerFooter: {
      firstHeader: 'Property Optimization Report - Hierarchical View',
      firstFooter: '&CGenerated by Property Optimization Tool'
    }
  });
  
  worksheet.columns = [
    { header: 'Property', key: 'property', width: 25 },
    { header: 'Unit Number', key: 'unitNumber', width: 15 },
    { header: 'TAG', key: 'tag', width: 15 },
    { header: 'Bedrooms', key: 'bedrooms', width: 12 },
    { header: 'Bathrooms', key: 'bathrooms', width: 12 },
    { header: 'Sq Ft', key: 'sqFt', width: 12 },
    { header: 'Current Rent', key: 'currentRent', width: 15 },
    { header: 'Optimal Rent', key: 'optimalRent', width: 15 },
    { header: 'Monthly Change', key: 'monthlyChange', width: 15 },
    { header: 'Annual Impact', key: 'annualImpact', width: 15 },
    { header: 'Status', key: 'status', width: 12 }
  ];
  
  const titleRow = worksheet.addRow(['Property Optimization Report - Hierarchical View']);
  titleRow.getCell(1).font = { size: 18, bold: true, color: { argb: 'FF2563EB' } };
  titleRow.height = 30;
  worksheet.mergeCells(titleRow.number, 1, titleRow.number, 11);
  
  const dateRow = worksheet.addRow(['Generated on:', new Date().toLocaleDateString()]);
  dateRow.getCell(1).font = { bold: true };
  worksheet.addRow([]);
  
  const headerRow = worksheet.addRow([
    'Property',
    'Unit Number',
    'TAG',
    'Bedrooms',
    'Bathrooms',
    'Sq Ft',
    'Current Rent',
    'Optimal Rent',
    'Monthly Change',
    'Annual Impact',
    'Status'
  ]);
  
  headerRow.eachCell((cell) => {
    cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
    cell.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF3B82F6' }
    };
    cell.border = {
      top: { style: 'thin' },
      left: { style: 'thin' },
      bottom: { style: 'thin' },
      right: { style: 'thin' }
    };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
  });
  
  const groupedData = groupUnitsByPropertyBedroomTag(data.units);
  
  Object.keys(groupedData).sort().forEach(propertyName => {
    const propertyData = groupedData[propertyName];
    let propertyTotal = 0;
    
    const propertyRow = worksheet.addRow([propertyName]);
    propertyRow.getCell(1).font = { bold: true, size: 12 };
    propertyRow.getCell(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE0F2FE' }
    };
    worksheet.mergeCells(propertyRow.number, 1, propertyRow.number, 11);
    propertyRow.eachCell((cell) => {
      cell.border = {
        top: { style: 'thin' },
        left: { style: 'thin' },
        bottom: { style: 'thin' },
        right: { style: 'thin' }
      };
    });
    
    Object.keys(propertyData).sort((a, b) => Number(a) - Number(b)).forEach(bedroomCount => {
      const bedroomData = propertyData[bedroomCount];
      let bedroomTotal = 0;
      
      const bedroomLabel = bedroomCount === '1' 
        ? '  1 Bedroom Units' 
        : `  ${bedroomCount} Bedroom Units`;
      
      const bedroomRow = worksheet.addRow([bedroomLabel]);
      bedroomRow.getCell(1).font = { italic: true };
      bedroomRow.getCell(1).fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FFF3F4F6' }
      };
      worksheet.mergeCells(bedroomRow.number, 1, bedroomRow.number, 11);
      bedroomRow.eachCell((cell) => {
        cell.border = {
          top: { style: 'thin' },
          left: { style: 'thin' },
          bottom: { style: 'thin' },
          right: { style: 'thin' }
        };
      });
      
      Object.keys(bedroomData).sort((a, b) => {
        // Sort TAGs by displayOrder from tag definitions
        const orderA = tagOrderMap.get(a) ?? 999;
        const orderB = tagOrderMap.get(b) ?? 999;
        
        if (orderA !== orderB) {
          return orderA - orderB;
        }
        
        // If display orders are the same, sort by tag name alphabetically
        return a.localeCompare(b);
      }).forEach(tag => {
        const units = bedroomData[tag];
        
        units.forEach(unit => {
          const row = worksheet.addRow([
            '',
            `    ${unit.unitNumber}`,
            unit.tag || '',
            unit.bedrooms ?? '',
            unit.bathrooms ?? '',
            unit.squareFootage ?? '',
            unit.currentRent,
            unit.recommendedRent || unit.currentRent,
            unit.change,
            unit.annualImpact,
            unit.status
          ]);
          
          bedroomTotal += unit.annualImpact;
          
          const changeCell = row.getCell(9);
          const impactCell = row.getCell(10);
          
          if (unit.change > 0) {
            changeCell.font = { color: { argb: 'FF059669' }, bold: true };
            changeCell.fill = {
              type: 'pattern',
              pattern: 'solid',
              fgColor: { argb: 'FFDCFCE7' }
            };
            impactCell.font = { color: { argb: 'FF059669' }, bold: true };
            impactCell.fill = {
              type: 'pattern',
              pattern: 'solid',
              fgColor: { argb: 'FFDCFCE7' }
            };
          } else if (unit.change < 0) {
            changeCell.font = { color: { argb: 'FFDC2626' }, bold: true };
            changeCell.fill = {
              type: 'pattern',
              pattern: 'solid',
              fgColor: { argb: 'FFFEF2F2' }
            };
            impactCell.font = { color: { argb: 'FFDC2626' }, bold: true };
            impactCell.fill = {
              type: 'pattern',
              pattern: 'solid',
              fgColor: { argb: 'FFFEF2F2' }
            };
          } else {
            changeCell.font = { color: { argb: 'FF6B7280' } };
            impactCell.font = { color: { argb: 'FF6B7280' } };
          }
          
          row.eachCell((cell) => {
            cell.border = {
              top: { style: 'thin' },
              left: { style: 'thin' },
              bottom: { style: 'thin' },
              right: { style: 'thin' }
            };
          });
          
          row.getCell(7).numFmt = '"$"#,##0.00';
          row.getCell(8).numFmt = '"$"#,##0.00';
          row.getCell(9).numFmt = '"$"#,##0.00';
          row.getCell(10).numFmt = '"$"#,##0.00';
        });
      });
      
      const subtotalRow = worksheet.addRow([
        `  ${bedroomCount}BR Subtotal`,
        '', '', '', '', '', '', '', '',
        bedroomTotal,
        ''
      ]);
      subtotalRow.getCell(1).font = { bold: true };
      subtotalRow.getCell(10).font = { bold: true, color: { argb: 'FF059669' } };
      subtotalRow.getCell(10).fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FFDCFCE7' }
      };
      subtotalRow.getCell(10).numFmt = '"$"#,##0.00';
      subtotalRow.eachCell((cell) => {
        cell.border = {
          top: { style: 'thin' },
          left: { style: 'thin' },
          bottom: { style: 'thin' },
          right: { style: 'thin' }
        };
      });
      
      propertyTotal += bedroomTotal;
    });
    
    const totalRow = worksheet.addRow([
      `${propertyName} Total`,
      '', '', '', '', '', '', '', '',
      propertyTotal,
      ''
    ]);
    totalRow.getCell(1).font = { bold: true, size: 12 };
    totalRow.getCell(10).font = { bold: true, color: { argb: 'FF059669' }, size: 12 };
    totalRow.getCell(10).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFDCFCE7' }
    };
    totalRow.getCell(10).numFmt = '"$"#,##0.00';
    totalRow.eachCell((cell) => {
      cell.border = {
        top: { style: 'thin' },
        left: { style: 'thin' },
        bottom: { style: 'thin' },
        right: { style: 'thin' }
      };
    });
    
    worksheet.addRow([]);
  });
  
  const buffer = await workbook.xlsx.writeBuffer();
  const blob = new Blob([buffer], { 
    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
  });
  
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.href = url;
  link.download = `property-optimization-hierarchical-${Date.now()}.xlsx`;
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
