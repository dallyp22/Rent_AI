import ExcelJS from 'exceljs';
import { formatCurrency } from '@/utils/formatters';

// Helper function to format square footage
function formatSquareFootage(sqft: number | undefined | null): string {
  if (sqft === undefined || sqft === null) {
    return '-';
  }
  
  // Format with comma separator and add "sq ft" suffix
  return sqft.toLocaleString() + ' sq ft';
}

// Helper function to format power score
function formatPowerScore(score: number | undefined | null): string {
  if (score === undefined || score === null) {
    return '-';
  }
  return `${Math.round(score)}%`;
}

// Helper function to format availability date
function formatAvailabilityDate(date: string | null | undefined, status: string): string {
  if (!date || date === 'Contact for availability') {
    return status === 'available' ? 'Available Now' : 'Contact for availability';
  }
  
  // First check if the date already looks like a formatted date (e.g., "Oct 17", "Dec 1")
  // This should be checked BEFORE trying to parse to avoid wrong year issues
  if (/^[A-Za-z]{3}\s+\d{1,2}$/.test(date)) {
    // Add current year if not present
    const currentYear = new Date().getFullYear();
    return `${date}, ${currentYear}`;
  }
  
  const lowerDate = date.toLowerCase();
  
  // Only return "Available Now" if the date string explicitly says so
  if (lowerDate.includes('available now') || lowerDate.includes('immediately')) {
    return 'Available Now';
  }
  
  // Try to parse the date (for dates that include year or are in other formats)
  try {
    const parsedDate = new Date(date);
    if (!isNaN(parsedDate.getTime())) {
      const options: Intl.DateTimeFormatOptions = { month: 'short', day: 'numeric', year: 'numeric' };
      return parsedDate.toLocaleDateString('en-US', options);
    }
  } catch {
    // Fall back to original string if parsing fails
  }
  
  return date;
}

export interface ExcelExportData {
  propertyInfo: {
    address: string;
    type: string;
    units: number;
    builtYear: number;
  };
  units: Array<{
    propertyName?: string;
    propertyType?: 'Subject' | 'Competitor'; // Add property type to distinguish
    unitNumber: string;
    tag?: string;
    unitType: string;
    floorPlanName?: string | null;
    bedrooms?: number | null;
    bathrooms?: number | string | null;
    pricingPowerScore?: number;
    squareFootage?: number;
    currentRent: number;
    recommendedRent?: number;
    adjustmentReason?: string;
    change: number;
    annualImpact: number;
    status: string;
    availabilityDate?: string | null;
    reasoning?: string;
  }>;
  summary: {
    totalIncrease: number;
    affectedUnits: number;
    avgIncrease: number;
    riskLevel: string;
  };
  marketInsights?: {
    occupancyImpact: string;
    competitivePosition: string;
    timeToLease: string;
  };
}

export async function exportToExcel(data: ExcelExportData): Promise<void> {
  const workbook = new ExcelJS.Workbook();
  workbook.creator = 'Property Optimization Tool';
  workbook.lastModifiedBy = 'Property Optimization Tool';
  workbook.created = new Date();
  workbook.modified = new Date();
  
  // Create main worksheet
  const worksheet = workbook.addWorksheet('Optimization Report', {
    headerFooter: {
      firstHeader: 'Property Optimization Report',
      firstFooter: '&CGenerated by Property Optimization Tool'
    }
  });
  
  // Set column widths
  worksheet.columns = [
    { header: 'Property Type', key: 'propertyType', width: 15 },
    { header: 'Property', key: 'propertyName', width: 25 },
    { header: 'Unit Number', key: 'unitNumber', width: 15 },
    { header: 'Floor Plan', key: 'floorPlanName', width: 18 },
    { header: 'TAG', key: 'tag', width: 20 },
    { header: 'Unit Type', key: 'unitType', width: 15 },
    { header: 'Beds', key: 'bedrooms', width: 8 },
    { header: 'Baths', key: 'bathrooms', width: 8 },
    { header: 'Square Footage', key: 'squareFootage', width: 15 },
    { header: 'Current Rent', key: 'currentRent', width: 15 },
    { header: 'AI Recommended', key: 'recommendedRent', width: 18 },
    { header: 'Adjustment Reason', key: 'adjustmentReason', width: 30 },
    { header: 'Monthly Change', key: 'change', width: 15 },
    { header: 'Annual Impact', key: 'annualImpact', width: 15 },
    { header: 'Status', key: 'status', width: 12 },
    { header: 'Availability Date', key: 'availabilityDate', width: 18 },
    { header: 'Notes', key: 'notes', width: 40 }
  ];
  
  // Add title and property info
  const titleRow = worksheet.addRow(['Property Optimization Report']);
  titleRow.getCell(1).font = { size: 18, bold: true, color: { argb: 'FF2563EB' } };
  titleRow.height = 30;
  
  worksheet.addRow(['Generated on:', new Date().toLocaleDateString()]);
  worksheet.addRow([]);
  
  // Property Information Section
  const propertyHeaderRow = worksheet.addRow(['Property Information']);
  propertyHeaderRow.getCell(1).font = { size: 14, bold: true, color: { argb: 'FF059669' } };
  
  worksheet.addRow(['Address:', data.propertyInfo.address]);
  worksheet.addRow(['Property Type:', data.propertyInfo.type]);
  worksheet.addRow(['Total Units:', data.propertyInfo.units]);
  worksheet.addRow(['Built Year:', data.propertyInfo.builtYear]);
  worksheet.addRow([]);
  
  // Units Section Header
  const unitsHeaderRow = worksheet.addRow(['Unit-by-Unit Optimization']);
  unitsHeaderRow.getCell(1).font = { size: 14, bold: true, color: { argb: 'FF059669' } };
  worksheet.addRow([]);
  
  // Add header row for units table
  const headerRow = worksheet.addRow([
    'Property Type',
    'Property',
    'Unit Number',
    'Floor Plan',
    'TAG',
    'Unit Type',
    'Beds',
    'Baths',
    'Square Footage',
    'Current Rent',
    'AI Recommended',
    'Adjustment Reason',
    'Monthly Change',
    'Annual Impact',
    'Status',
    'Availability Date',
    'Notes'
  ]);
  
  // Style header row
  headerRow.eachCell((cell) => {
    cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
    cell.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF3B82F6' }
    };
    cell.border = {
      top: { style: 'thin' },
      left: { style: 'thin' },
      bottom: { style: 'thin' },
      right: { style: 'thin' }
    };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
  });
  
  // Add unit data with conditional formatting
  data.units.forEach((unit) => {
    // For competitor properties, show different values in optimization columns
    const isCompetitor = unit.propertyType === 'Competitor';
    
    const row = worksheet.addRow([
      unit.propertyType || 'Subject',
      unit.propertyName || '',
      unit.unitNumber,
      unit.floorPlanName || '-',
      unit.tag || '-',
      unit.unitType,
      unit.bedrooms ?? '-',
      unit.bathrooms ?? '-',
      formatSquareFootage(unit.squareFootage),
      unit.currentRent,
      isCompetitor ? '-' : (unit.recommendedRent || unit.currentRent),
      isCompetitor ? '-' : (unit.adjustmentReason || ''),
      isCompetitor ? '-' : unit.change,
      isCompetitor ? '-' : unit.annualImpact,
      unit.status,
      formatAvailabilityDate(unit.availabilityDate, unit.status),
      unit.reasoning || 'No additional notes'
    ]);

    // Apply conditional formatting based on change amount (only for subject properties)
    const changeCell = row.getCell(13); // Monthly Change column
    const impactCell = row.getCell(14); // Annual Impact column
    
    if (!isCompetitor) {
      if (unit.change > 0) {
        // Positive change - green
        changeCell.font = { color: { argb: 'FF059669' }, bold: true };
        changeCell.fill = {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: 'FFDCFCE7' }
        };
        impactCell.font = { color: { argb: 'FF059669' }, bold: true };
        impactCell.fill = {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: 'FFDCFCE7' }
        };
      } else if (unit.change < 0) {
        // Negative change - red
        changeCell.font = { color: { argb: 'FFDC2626' }, bold: true };
        changeCell.fill = {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: 'FFFEF2F2' }
        };
        impactCell.font = { color: { argb: 'FFDC2626' }, bold: true };
        impactCell.fill = {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: 'FFFEF2F2' }
        };
      } else {
        // No change - gray
        changeCell.font = { color: { argb: 'FF6B7280' } };
        impactCell.font = { color: { argb: 'FF6B7280' } };
      }
    }
    
    // Style competitor rows differently (light blue background)
    if (isCompetitor) {
      row.eachCell((cell) => {
        cell.fill = {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: 'FFF0F9FF' } // Light blue for competitor rows
        };
      });
    }
    
    // Add borders to all cells
    row.eachCell((cell) => {
      cell.border = {
        top: { style: 'thin' },
        left: { style: 'thin' },
        bottom: { style: 'thin' },
        right: { style: 'thin' }
      };
    });
    
    // Format currency cells
    row.getCell(10).numFmt = '"$"#,##0.00'; // Current Rent
    if (!isCompetitor) {
      row.getCell(11).numFmt = '"$"#,##0.00'; // AI Recommended
      row.getCell(13).numFmt = '"$"#,##0.00'; // Monthly Change
      row.getCell(14).numFmt = '"$"#,##0.00'; // Annual Impact
    }
  });
  
  worksheet.addRow([]);
  
  // Summary Section
  const summaryHeaderRow = worksheet.addRow(['Optimization Summary']);
  summaryHeaderRow.getCell(1).font = { size: 14, bold: true, color: { argb: 'FF059669' } };
  
  const summaryData = [
    ['Total Annual Revenue Increase:', formatCurrency(data.summary.totalIncrease)],
    ['Units Affected:', data.summary.affectedUnits],
    ['Average Rent Increase:', `${data.summary.avgIncrease}%`],
    ['Risk Level:', data.summary.riskLevel]
  ];
  
  summaryData.forEach(([label, value]) => {
    const row = worksheet.addRow([label, value]);
    row.getCell(1).font = { bold: true };
    if (typeof label === 'string' && label.includes('Revenue Increase') && typeof value === 'string' && value.startsWith('$')) {
      row.getCell(2).font = { color: { argb: 'FF059669' }, bold: true };
    }
  });
  
  // Market Insights Section (if available)
  if (data.marketInsights) {
    worksheet.addRow([]);
    const insightsHeaderRow = worksheet.addRow(['Market Insights']);
    insightsHeaderRow.getCell(1).font = { size: 14, bold: true, color: { argb: 'FF059669' } };
    
    worksheet.addRow(['Occupancy Impact:', data.marketInsights.occupancyImpact]);
    worksheet.addRow(['Competitive Position:', data.marketInsights.competitivePosition]);
    worksheet.addRow(['Time to Lease:', data.marketInsights.timeToLease]);
  }
  
  // Generate and download the file
  const buffer = await workbook.xlsx.writeBuffer();
  const blob = new Blob([buffer], { 
    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
  });
  
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.href = url;
  link.download = `property-optimization-${Date.now()}.xlsx`;
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

// Export alias for optimization-specific naming
export async function exportOptimizationToExcel(data: ExcelExportData): Promise<void> {
  return exportToExcel(data);
}
